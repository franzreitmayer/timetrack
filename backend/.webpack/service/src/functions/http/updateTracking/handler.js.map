{"version":3,"sources":["webpack://ttapi/./src/businessLogic/timetrack.ts","webpack://ttapi/./src/dataAccess/timetrackAccess.ts","webpack://ttapi/./src/libs/lambda.ts","webpack://ttapi/./src/util/logger.ts","webpack://ttapi/external \"@middy/core\"","webpack://ttapi/external \"@middy/http-json-body-parser\"","webpack://ttapi/external \"aws-sdk\"","webpack://ttapi/external \"aws-xray-sdk\"","webpack://ttapi/external \"source-map-support/register\"","webpack://ttapi/external \"uuid\"","webpack://ttapi/external \"winston\"","webpack://ttapi/webpack/bootstrap","webpack://ttapi/webpack/runtime/compat get default export","webpack://ttapi/webpack/runtime/define property getters","webpack://ttapi/webpack/runtime/hasOwnProperty shorthand","webpack://ttapi/webpack/runtime/make namespace object","webpack://ttapi/./src/functions/http/updateTracking/handler.ts"],"names":["timetrackAccess","async","updateTimetracking","timetrack","updateTimetrack","XAWS","TimetrackAccess","docClient","DynamoDB","DocumentClient","createDynamoDBClient","timetrackTable","process","env","TTRACK_TABLE","indexName","SECONDARY_INDEX","LOGGER","userId","result","this","info","query","TableName","IndexName","KeyConditionExpression","ExpressionAttributeValues","promise","error","JSON","stringify","console","log","Items","put","Item","err","update","Key","trackingId","UpdateExpression","trackTo","trackFrom","shortDescription","longDescription","invoiced","attachmentUrl","trackId","delete","middyfy","handler","use","createLogger","loggerName","level","format","defaultMeta","name","transports","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","main","event","body","trackingToBeUpdated","parse","updatedTracking","statusCode","headers"],"mappings":"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","file":"src/functions/http/updateTracking/handler.js","sourcesContent":["import * as uuid from 'uuid'\r\n\r\nimport { Timetrack } from '@models/Timetrack'\r\nimport { TimetrackAccess } from '@dataAccess/timetrackAccess'\r\n\r\nconst timetrackAccess = new TimetrackAccess()\r\n\r\n/**\r\n * business logic to create \r\n */\r\n export async function getAllTimetrackings(userId: String): Promise<Timetrack[]> {\r\n    return timetrackAccess.getAllTimetrackings(userId)\r\n}\r\n\r\nexport async function createTimetracking(timetrack: Timetrack): Promise<Timetrack> {\r\n    const newTimetrackId = uuid.v4();\r\n\r\n    timetrack.trackingId = newTimetrackId;\r\n\r\n    return timetrackAccess.createTimetrack(timetrack);\r\n}\r\n\r\nexport async function updateTimetracking(timetrack: Timetrack): Promise<Timetrack> {\r\n    return await timetrackAccess.updateTimetrack(timetrack)\r\n}\r\n\r\nexport async function deleteTimetrack(trackId: string, userId: string): Promise<Boolean>{\r\n    return await timetrackAccess.deleteTimetrack(trackId, userId);\r\n}","import * as AWS from 'aws-sdk'\r\nimport * as AWSXRay from 'aws-xray-sdk'\r\nimport { DocumentClient } from 'aws-sdk/clients/dynamodb'\r\nimport { createLogger } from '@util/logger'\r\nimport { Timetrack } from '@models/Timetrack'\r\n\r\nconst XAWS = AWSXRay.captureAWS(AWS)\r\n\r\nexport class TimetrackAccess {\r\n    constructor(\r\n        private readonly docClient: DocumentClient = createDynamoDBClient(),\r\n        private readonly timetrackTable = process.env.TTRACK_TABLE,\r\n        private readonly indexName = process.env.SECONDARY_INDEX,\r\n        private readonly LOGGER = createLogger(\"TIMETRACK_ACCESS\")) { }\r\n\r\n    async getAllTimetrackings(userId: String): Promise<Timetrack[]> {\r\n        this.LOGGER.info('Getting all todo items')\r\n\r\n        // const result = await this.docClient.scan(\r\n        //     { TableName: this.todoTable }\r\n        // ).promise()\r\n\r\n        var result;\r\n        try {\r\n            result = await this.docClient.query(\r\n                {\r\n                    TableName: this.timetrackTable,\r\n                    IndexName: this.indexName,\r\n                    KeyConditionExpression: \"userId = :userId\",\r\n                    ExpressionAttributeValues: {\r\n                        \":userId\": userId\r\n                    }\r\n                }\r\n            ).promise()\r\n        } catch (error) {\r\n\r\n            this.LOGGER.error(\"error during query\").error(JSON.stringify(error))\r\n\r\n        }\r\n\r\n        console.log(\"Got result from dynamodb: \" + JSON.stringify(result))\r\n        const items = result.Items\r\n        return items as Timetrack[]\r\n    }\r\n\r\n    async createTimetrack(timetrack: Timetrack): Promise<Timetrack> {\r\n        this.LOGGER.info(`Creaing new Timetrack ${JSON.stringify(timetrack)}` );\r\n        \r\n        try {\r\n            await this.docClient.put({\r\n                TableName: this.timetrackTable,\r\n                Item: timetrack\r\n            }).promise();\r\n            this.LOGGER.info(`Timetrack written to db table ${this.timetrackTable}: ${JSON.stringify(timetrack)}`);\r\n        } catch (err)  {\r\n            this.LOGGER.error(`Writing timetrack ${JSON.stringify(timetrack)} to table ${this.timetrackTable} failed`, err);\r\n        }\r\n        return timetrack;\r\n    }\r\n\r\n    async updateTimetrack(timetrack: Timetrack): Promise<Timetrack> {\r\n        this.LOGGER.info(`Updating Timetrack: ${timetrack}`);\r\n\r\n        try {\r\n            await this.docClient.update({\r\n                TableName: this.timetrackTable,\r\n                Key: {\r\n                    userId: timetrack.userId,\r\n                    trackingId: timetrack.trackingId\r\n                },\r\n                UpdateExpression: `set  trackTo=:trackTo, \r\n                                        trackFrom=:trackFrom, \r\n                                        shortDescription=:shortDescription, \r\n                                        longDescription=:longDescription, \r\n                                        invoiced=:invoiced, \r\n                                        attachmentURL=:attachmentURL`,\r\n                ExpressionAttributeValues: {\r\n                    \":trackTo\":             timetrack.trackTo,\r\n                    \":trackFrom\":           timetrack.trackFrom,\r\n                    \":shortDescription\":    timetrack.shortDescription,\r\n                    \":longDescription\":     timetrack.longDescription,\r\n                    \":invoiced\":            timetrack.invoiced,\r\n                    \":attachmentURL\":       timetrack.attachmentUrl\r\n                }\r\n            }).promise()\r\n            this.LOGGER.info(\"Successfully updated timetrack\", timetrack)\r\n        } catch (err) {\r\n            this.LOGGER.error(\"Error updating timetrack\", err, timetrack)\r\n        }\r\n        return timetrack\r\n    }\r\n\r\n    async deleteTimetrack(trackId: string, userId: string): Promise<Boolean> {\r\n        this.LOGGER.info(`deleting timetrack with id: ${trackId} and userId: ${userId}`)\r\n\r\n        try {\r\n            await this.docClient.delete({\r\n                TableName: this.timetrackTable,\r\n                Key: {\r\n                    \"userId\": userId,\r\n                    \"trackId\": trackId\r\n                }\r\n            }).promise()\r\n            this.LOGGER.info(`Successfully deleted timetrack with id ${trackId} and user ${userId}`) \r\n            return true\r\n        } catch (err) {\r\n            this.LOGGER.error(`Error while deleting trackId: ${trackId} and userId: ${userId}`, err)\r\n            return false\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * helper function to create the document client\r\n */\r\nfunction createDynamoDBClient(): DocumentClient {\r\n    return new XAWS.DynamoDB.DocumentClient()\r\n}","import middy from \"@middy/core\"\nimport middyJsonBodyParser from \"@middy/http-json-body-parser\"\n\nexport const middyfy = (handler) => {\n  return middy(handler).use(middyJsonBodyParser())\n}\n","import * as winston from 'winston'\r\n\r\n/**\r\n * Create a logger instance to write log messages in JSON format.\r\n *\r\n * @param loggerName - a name of a logger that will be added to all messages\r\n */\r\nexport function createLogger(loggerName: string) {\r\n  return winston.createLogger({\r\n    level: 'info',\r\n    format: winston.format.json(),\r\n    defaultMeta: { name: loggerName },\r\n    transports: [\r\n      new winston.transports.Console()\r\n    ]\r\n  })\r\n}","module.exports = require(\"@middy/core\");;","module.exports = require(\"@middy/http-json-body-parser\");;","module.exports = require(\"aws-sdk\");;","module.exports = require(\"aws-xray-sdk\");;","module.exports = require(\"source-map-support/register\");;","module.exports = require(\"uuid\");;","module.exports = require(\"winston\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import 'source-map-support/register';\r\n\r\n//import * as AWS  from 'aws-sdk'\r\n// import { APIGatewayProxyHandler, APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda'\r\nimport { APIGatewayProxyHandler } from 'aws-lambda'\r\n// import type { ValidatedEventAPIGatewayProxyEvent } from '@libs/apiGateway';\r\n//import { formatJSONResponse } from '@libs/apiGateway';\r\nimport { updateTimetracking } from '@businessLogic/timetrack'\r\nimport { middyfy } from '@libs/lambda'\r\n// import { getUserId } from '@util/userHelper'\r\n// import { Timetrack } from '@models/Timetrack'\r\n\r\nconst updateTracking: APIGatewayProxyHandler = async (event) => {\r\n  console.log(JSON.stringify(event))\r\n  \r\n  // extract payload\r\n  console.log(`event.body = ${event.body}`);\r\n  const trackingToBeUpdated = JSON.parse(JSON.stringify(event.body)) ;\r\n\r\n  // set userid from bearer token\r\n  // const userId = await getUserId(event);\r\n  // trackingToBeUpdated.userId = userId;\r\n\r\n  // create the new tracking utilizing the business logic layer\r\n  const updatedTracking = await updateTimetracking(trackingToBeUpdated);\r\n\r\n  // return the timetracking created back to client\r\n  return {\r\n    statusCode: 200,\r\n    headers: {\r\n      'Access-Control-Allow-Origin': '*'\r\n    },\r\n    body: JSON.stringify(updatedTracking)\r\n  }\r\n}\r\n\r\nexport const main = middyfy(updateTracking);"],"sourceRoot":""}